C:\Users\tzhen104\Downloads\Lab 2\Lab 2\alarm.lst - generated by MGTEK Assembler ASM12 V1.26 Build 144 for WIN32 (x86) - Wed Oct 09 15:25:23 2024

    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: alarm.asm (Alarm System Module)
    4:                                 ; Author: Gilbert Arbez - Hamzah Alghamdi(modified)
    5:                                 ; Date: Fall 2019
    6:                                 ;------------------------------------------------------
   10:                                 
   11:                                 ; Some definitions
   12:                                 ; Location of the register block
   13:          =00000000              Regblk:       equ    $0000 
   14:                                  INCLUDE sections.inc
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
    9:          =00000001              SECTIONS_DEFINED   EQU  1        ; prevents future inclusion of the file
   10:                                 
   11:                                 ; Define addresses of various sections
   12:          =00003000              VARIABLES EQU $3000   ; $3000 - $3FFF
   13:          =00002000              PROGRAM   EQU $2000  ; $2000 - $2FFF
   14:          =00002000              STACK     EQU $2000  ; $1000 - $1FFF
   15:                                 
   16:                                 ;----------------------------------------
   17:                                 ; Global Variable section
   18:                                 ; Use the DS - define storage directive
   19:                                 ;              to define space for 
   20:                                 ;              global variables and data
   21:                                 ;              structures.
   22:                                 ;----------------------------------------
   23:                                 globalVar SECTION
   24:          =00003000                      ORG VARIABLES   ; places section in RAM
   25:                                 ;-----------------------------------------
   26:                                 ; Code section
   27:                                 ; Enter assembly instructions (HCS12) to create
   28:                                 ; executable code.
   29:                                 ;-----------------------------------------
   30:                                 code_section SECTION
   31:          =00002000                      ORG PROGRAM  ; places section in RAM - simulates ROM
   32:                                 
   33:                                 ;------------------------------------------
   34:                                 ; Global constants
   35:                                 ; In simple programs (single module) global constants are 
   36:                                 ; simply placed at the end of code and not section is
   37:                                 ; explicitly defined.
   38:                                 ;--------------------------------------------
   39:                                 globalConst SECTION
   40:          =000024C2                      ORG ENDCODE ;--ENDCODE is defined on the second pass of the assembler
   41:                                 
   42:                                 ;----------------------------------------------
   43:                                 ; Defining the start of the globalConst Section
   44:                                 ; The following should be added to the end of the 
   45:                                 ; main module
   46:                                 ;----------------------------------------------
   47:                                 ;       SWITCH code_section 
   48:                                 ;ENDCODE        
   49:                                 
   50:                                          ENDIF  ; End of conditional assembly
   15:                                  INCLUDE alarm.inc
    1:                                 ;---------------------------------
    2:                                 ; File: alarmSimul.inc
    3:                                 ; Description: Include file for Alarm System Simulation
    4:                                 ;              project
    5:                                 ;----------------------------------------------
    6:                                         IFNDEF ALARM_SIMUL_HDR  ; Start of conditional assembly
    7:          =00000001              ALARM_SIMUL_HDR   EQU   1        ; prevents future inclusion of the file
    8:                                 
    9:                                 ; for calculating wins
   10:          =000000FF              NOCHAR        equ    0xff
   11:          =00000007              BEL           equ    0x07
   12:          =00000001              TRUE          equ    1
   13:          =00000000              FALSE         equ    0
   14:          =00000005              NUMCODES      equ    5
   15:          =00000008              XWINSUM        equ   ('X'+'X'+'X')&$FF  ; sum of three X's
   16:          =000000ED              OWINSUM        equ   'O'+'O'+'O'        ; sum of three O's
   17:          =0000000A              NL             equ   $0a                ; NEWLINE
   18:          =0000000D              CR             equ   $0d                ; carriage return
   19:          =00000030              ASCII_CONV_NUM equ   $30                ; For converting digit to ASCII
   20:                                 
   21:                                          ENDIF  ; End of conditional assembly
   16:                                 
   17:                                 ; Dbug12 subroutines
   18:          =0000EE86              putchar        equ   $EE86
   19:          =0000EE84              getchar        equ   $EE84
   20:          =0000EE88              printf         equ   $EE88
   21:          =0000EEA6              writeEEByte    equ   $EEA6
   22:                                 
   23:                                         switch code_section
   24:                                 ;------------------------------------------------------
   25:                                 ; Alarm System Module
   26:                                 
   27:                                 ; Main routine
   28:                                 ; Variables: select - in register B (set by getchar)
   29:                                 ; Description: The main routine for running the game.
   30:                                 ;              Initialises things (via initgb) and the
   31:                                 ;              loops forever playing games.
   32:                                 ;------------------------------------------------------
   33:     2000 CF 2000                        lds #STACK       ; Not reflected in C
   34:     2003 07 27                          bsr inithw       ; initiliase the hardware
   35:     2005 16 2377                        jsr initKeyPad   ;  initKeyPad();
   36:     2008 16 249A                        jsr initSwitches ;  initSwithes();
   37:                                         ; byte select - in register B
   38:                                                         ;do
   39:                                 
   40:     200B                        mainloop:                       ; {
   41:     200B CC 24CC                        ldd #MENU          ;   printf(MENU);
   42:     200E 15 FB CE76                     jsr [printf,PCr] 
   43:     2012 16 2382                        jsr readKey        ;   select = readKey();
   44:     2015 37                             pshb ; save b
   45:     2016 33                             pulb
   46:     2017 C1 63                          cmpb #'c'          ;   if(select == 'c') configCodes();
   47:     2019 26 05                          bne mnElseif
   48:     201B 16 2062                        jsr configCodes
   49:     201E 20 09                          bra mnEndif
   50:     2020 C1 61                  mnElseif cmpb #'a'         ;   else if(select == 'a') enableAlarm();
   51:     2022 26 05                          bne mnElse
   52:     2024 16 21BC                        jsr enableAlarm
   53:     2027 20 00                          bra mnEndif
   54:     2029                        mnElse                     ;   else /*do nothing*/;
   55:     2029                        mnEndif:
   56:     2029 20 E0                          bra mainloop       ; } while(1);  // loop forever
   57:     202B 3F                             swi                ; never reach here - infinite loop
   58:                                 
   59:                                 ;------------------------------------------------------
   60:                                 ; Subroutine: inithw
   61:                                 ; No parameters
   62:                                 ; Variables: ptx - index register X
   63:                                 ;            pty - index register Y
   64:                                 ; Description: First setup up the microcontroller setting up the clock, 
   65:                                 ;             shutting down the COP watchdog timer, and initialising 
   66:                                 ;             the SCI serial interface. Initialises global variables also.
   67:                                 ;------------------------------------------------------
   68:     202C                        inithw:
   69:                                 ; -- Initialise the hardware
   70:                                 ; Initialise the Phase-Lock-Loop (se page 34 of Dragon 12 Manual
   71:                                 ;       The crystal freq. on the DRAGON12 Plus board is 8 MHz so the default bus speed is 2 MHz
   72:                                 ;       In order to set the bus speed higher than 4 MHz the PLL must be initialized
   73:                                 ;
   74:                                 ;       The math used to set the PLL frequency is:
   75:                                 ;        
   76:                                 ;       PLLCLK = CrystalFreq * 2 * (initSYNR+1) / (initREFDV+1)
   77:                                 ;       
   78:                                 ;       If CrystalFreq = 8Mhz on DRAGON12 Plus board
   79:                                 ;         initSYNR     = 5    PLL multiplier will be 6
   80:                                 ;         initREFDV    = 0    PLL divisor will be 1
   81:                                 
   82:                                 ;       PLLCLK = 4*2*6/1 = 48MHz
   83:                                 ;       The bus speed = PLLCLK / 2 = 24 MHz
   84:                                 ;
   85:                                 ;      
   86:                                 ;********PLL code for 24MHz bus speed from a 4/8/16 crystal
   87:     202C 1410                           sei
   88:     202E CE 0000                        ldx #Regblk
   89:     2031 0D E0 39 80                    bclr Clksel,x,%10000000  ; clear bit 7, clock derived from oscclk
   90:     2035 0C E0 3A 40                    bset Pllctl,x,%01000000  ; Turn PLL on, bit 6 =1 PLL on, bit 6=0 PLL off
   91:     2039 86 05                          ldaa #$05                ; 5+1=6 multiplier 
   92:     203B 6A E0 34                       staa Synr,x
   93:                                 ;        ldaa #$03                ; divisor=3+1=4, 16 *6 /4 = 24Mhz for 16 MHz crystal
   94:     203E 86 01                          ldaa #$01                ; divisor=1+1=2,  8 *6 /2 = 24Mhz for  8 MHz crystal
   95:                                 ;        ldaa #$00                ; divisor=0+1=1,  4 *6 /1 = 24Mhz for  4 MHz crystal
   96:     2040 6A E0 35                       staa Refdv,x
   97:     2043                        wait_b3:
   98:     2043 0F E0 37 08 FB                 brclr Crgflg,x, %00001000 wait_b3  ; Wait until bit 3 = 1
   99:     2048 0C E0 39 80                    bset Clksel,x, %10000000
  100:                                 
  101:                                         ; Setup Serial port
  102:     204C CC 009C                        ldd #156
  103:     204F 5C C8                          std Sc0bdh   ; Sets up the baud rate
  104:     2051 86 0C                          ldaa #$0c
  105:     2053 5A CB                          staa Sc0cr2  ; Enables serial interface
  106:                                         
  107:                                         ; Setup the data in the RAM
  108:                                         ; For the Configuration Module
  109:     2055 1803 0000 3002                 movw #0,alarmCode
  110:     205B 1803 03E8 3000                 movw #1000,mult
  111:     2061 3D                             rts
  112:                                 
  113:                                    switch globalConst
  114:                                 
  115:                                 ;-------------------------------------------------------------------------
  116:                                 ; Data Structures
  117:                                 ; The following data is stored in EEPROM 
  118:                                 ; Following is data array used by testWin 
  119:                                 ;   int alarmCodes[NUMCODES] = { 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF }; 
  120:                                 ;------------------------------------------------------
  121:     24C2 0000 FFFF FFFF         alarmCodes dc.w $0000, $FFFF, $FFFF, $FFFF, $FFFF  ; note this will be updated in ROM
           24C8 FFFF FFFF 
  122:                                 
  123:                                 ; Message strings
  124:     24CC 43 45 47 33 31 33      MENU     dc.b   "CEG3136 Alarm",NL,CR,"c-Config a-Arm",NL,CR,$00
           24D2 36 20 41 6C 61 72 
           24D8 6D 0A 0D 63 2D 43 
           24DE 6F 6E 66 69 67 20 
           24E4 61 2D 41 72 6D 0A 
           24EA 0D 00 
  125:     24EC 0A 0D 00               NEWLINE  dc.b   NL,CR,$00
  126:                                 
  127:                                  
  128:                                 ;----------
  129:                                 ; Include other modules here
  130:                                 ;-----------
  131:                                  INCLUDE        config.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: config.asm - the CONFIGURATION Module
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
    7:                                 
    8:                                         SWITCH code_section ; include in the code
    9:                                 ;-----------------------------------
   10:                                 ; Subroutine - configCodes
   11:                                 ; Parameters: none
   12:                                 ; Returns: nothing
   13:                                 ; Local Variables:   ix,  input, flag - on stack
   14:                                 ; Description: Gets user to select alarm code to update/disable. Calls
   15:                                 ;              setcode to update the alarm code.
   16:                                 ;------------------------------------------------------
   17:                                 ; Stack Usage
   18:                                         OFFSET 0 ; to setup offsets into stack
   19:     0000 +0001                  CFG_IX   DS.B 1   ; ix
   20:     0001 +0001                  CFG_INPUT DS.B 1  ; input
   21:     0002 +0001                  CFG_FLAG DS.B 1   ; flag
   22:     0003                        CFG_VARSIZE:
   23:     0003 +0002                  CFB_PR_D        DS.W 1  ; preserve D 
   24:     0005 +0002                  CFG_RA  DS.W 1  ; return address
   25:                                 
   26:     2062 3B                     configCodes: pshd
   27:                                       ; byte ix;  // index into array
   28:                                       ; byte input; // input from user.
   29:                                       ; byte flag;
   30:     2063 1B 9D                        leas -CFG_VARSIZE,SP
   31:     2065 16 20A9                cfg_if1: jsr enterMstCode ; if(enterMstCode())
   32:     2068 97                           tsta
   33:     2069 27 3A                        beq cfg_endif1
   34:     206B                        cfg_loop:               ;     do {
   35:     206B CC 24FD                      ldd #CONFIGMSG    ;          printf(CONFIGMSG);
   36:     206E 15 FB CE16                   jsr [printf,PCr]
   37:     2072 16 2382                      jsr readKey ;          input = readKey();
   38:     2075 6B 81                        stab CFG_INPUT,SP ;
   39:     2077 1808 82 01                   movb #TRUE,CFG_FLAG,SP;      flag = TRUE;
   40:     207B                        cfg_if2:
   41:     207B A6 81                        ldaa CFG_INPUT,SP ;          if(input == 'a')
   42:     207D 81 61                        cmpa #'a'
   43:     207F 26 07                        bne cfg_elseif2
   44:     2081 86 00                        ldaa #0           ;               setcode(0);
   45:     2083 16 2108                      jsr setcode
   46:     2086 20 19                        bra cfg_endif2
   47:     2088                        cfg_elseif2:
   48:     2088 81 31                        cmpa #'1'         ;           else if( input>='1' && input <= '4')
   49:     208A 25 0A                        blo cfg_else2
   50:     208C 81 34                        cmpa #'4'
   51:     208E 22 06                        bhi cfg_else2
   52:     2090 80 30                        suba #ASCII_CONV_NUM  ;       {   ix = input-ASCII_CONV_NUM;
   53:     2092 07 74                        bsr setcode           ;           setcode(ix); }
   54:     2094 20 0B                        bra cfg_endif2
   55:     2096                        cfg_else2:              ;           else      
   56:     2096 CC 2510                      ldd #CERRMSG      ;           { printf(CERRMSG);
   57:     2099 15 FB CDEB                   jsr [printf,PCr]  ;
   58:     209D 1808 82 00                   movb #FALSE,CFG_FLAG,SP ;       flag = FALSE; }
   59:     20A1                        cfg_endif2:
   60:     20A1 E7 82                        tst CFG_FLAG,SP   ;       } while(!flag);
   61:     20A3 27 C6                        beq cfg_loop
   62:     20A5                        cfg_endif1:
   63:     20A5 1B 83                        leas CFG_VARSIZE,SP
   64:     20A7 3A                           puld
   65:     20A8 3D                           rts
   66:                                 
   67:                                 ;--------------------------------
   68:                                 ; Subroutine: enterMstCode
   69:                                 ; Parameters: none
   70:                                 ; Returns: TRUE - valid code entered, FALSE otherwise - Acc A.
   71:                                 ; Description: Prompts user for the 4 digit master alarm code.
   72:                                 ;-------------------------------
   73:                                 ; Stack Usage
   74:                                         OFFSET 0 ; to setup offsets into stack
   75:     0000 +0001                  EMC_RETVAL  DS.B 1   ; retval
   76:     0001 +0001                  EMC_I       DS.B 1   ; i
   77:     0002 +0001                  EMC_INPUT   DS.B 1   ; input
   78:     0003 +0002                  EMC_ALARMCODE DS.W 1 ; alarmCode
   79:     0005 +0002                  EMC_MULT    DS.W 1   ; mult
   80:     0007                        EMC_VARSIZE:
   81:     0007 +0002                  EMC_PR_Y    DS.W 1   ; preserve Y
   82:     0009 +0002                  EMC_PR_X    DS.W 1   ; preserve X
   83:     000B +0001                  EMC_PR_B    DS.B 1   ; preserve B
   84:     000C +0002                  EMC_RA      DS.W 1   ; return address
   85:                                 
   86:     20A9 37                     enterMstCode pshb
   87:     20AA 34                        pshx
   88:     20AB 35                        pshy
   89:     20AC 1B 99                     leas -EMC_VARSIZE,SP
   90:     20AE 1808 80 00                movb #FALSE,EMC_RETVAL,SP  ; byte retval = FALSE;
   91:                                                               ; byte i;
   92:                                                               ; byte input;
   93:     20B2 1800 83 0000              movw #0,EMC_ALARMCODE,SP   ; int alarmCode = 0;
   94:     20B7 1800 85 03E8              movw #1000,EMC_MULT,SP     ; int mult = 1000;
   95:                                    
   96:     20BC CC 24EF                   ldd #MSTCDMSG              ; printf(MSTCDMSG);
   97:     20BF 15 FB CDC5                jsr [printf, PCr]
   98:     20C3 69 81                     clr EMC_I,SP
   99:     20C5                        emc_for:                      ; for(i=0 ; i<4 ; i++)
  100:     20C5 16 2382                   jsr readKey                ; {
  101:     20C8 6B 82                     stab EMC_INPUT,SP          ;    input = readKey();
  102:     20CA                        emc_if1:
  103:     20CA 180F                      tba
  104:     20CC 16 247C                   jsr isdigit                ;    if(!isdigit(input))
  105:     20CF 97                        tsta
  106:     20D0 27 2E                     beq emc_endfor             ;         break;
  107:     20D2                        emc_else1:                    ;    else {
  108:     20D2 E6 82                     ldab EMC_INPUT,SP          ;       alarmCode = alarmCode + mult*(input-ASCII_CONV_NUM);
  109:     20D4 C0 30                     subb #ASCII_CONV_NUM
  110:     20D6 87                        clra
  111:     20D7 ED 85                     ldy  EMC_MULT,SP
  112:     20D9 13                        emul
  113:     20DA E3 83                     addd EMC_ALARMCODE,SP
  114:     20DC 6C 83                     std EMC_ALARMCODE,SP
  115:     20DE EC 85                     ldd EMC_MULT,SP            ;       mult = mult/10;
  116:     20E0 CE 000A                   ldx #10
  117:     20E3 1810                      idiv
  118:     20E5 6E 85                     stx EMC_MULT,SP
  119:     20E7 8E 0000                emc_if2: cpx #0               ;       if(mult == 0)  {
  120:     20EA 26 0B                     bne emc_endif2
  121:     20EC FC 24C2                emc_if3: ldd alarmCodes      ;            if(alarmCode == alarmCodes[0]) 
  122:     20EF AC 83                     cpd EMC_ALARMCODE,SP
  123:     20F1 26 04                     bne emc_endif3
  124:     20F3 1808 80 01                movb #TRUE,EMC_RETVAL,SP   ;                 retval = TRUE;
  125:     20F7                        emc_endif3:
  126:     20F7                        emc_endif2:                   ;       }
  127:     20F7                        emc_endif1:                   ;    }
  128:     20F7 A6 81                     ldaa EMC_I,SP
  129:     20F9 42                        inca
  130:     20FA 6A 81                     staa EMC_I,SP
  131:     20FC 81 04                     cmpa #4
  132:     20FE 25 C5                     blo emc_for
  133:     2100                        emc_endfor:                   ; }
  134:     2100 A6 80                     ldaa EMC_RETVAL,SP         ; return(retval);
  135:     2102 1B 87                     leas EMC_VARSIZE,SP
  136:     2104 31                        puly
  137:     2105 30                        pulx
  138:     2106 33                        pulb
  139:     2107 3D                        rts
  140:                                 
  141:                                 ;---------------------------------
  142:                                 ; Subroutine; setcode (ix)
  143:                                 ; Parameters
  144:                                 ;        ix - in accumulator a
  145:                                 ; Local variables
  146:                                 ;        flag, i, input, digit, alarmCode, mult - on stack
  147:                                 ; Description: Prompts user for a 4 digit alarm code to
  148:                                 ;              update the alarm code at index ix. If 'd'
  149:                                 ;              is entered the alarm code is disabled.  It
  150:                                 ;              is not allowed to diable the master
  151:                                 ;              alarm code.void setcode(byte ix).
  152:                                 ;------------------------------------------------------
  153:                                 ; Stack Usage
  154:                                         OFFSET 0 ; to setup offsets into stack
  155:     0000 +0001                  SETC_IX   DS.B 1  ; ix
  156:     0001 +0001                  SETC_FLAG DS.B 1  ; flag
  157:     0002 +0001                  SETC_I    DS.B 1  ; i
  158:     0003 +0001                  SETC_INPUT DS.B 1 ; input 
  159:     0004 +0002                  SETC_DIGIT DS.W 1 ; digit
  160:     0006 +0002                  SETC_ALARMCODE DS.W 1  ; alarmCode
  161:     0008 +0002                  SETC_MULT DS.W 1  ; mult
  162:     000A                        SETC_VARSIZE:
  163:     000A +0002                  SETC_PR_D DS.W 1        ; preserve D
  164:     000C +0002                  SETC_PR_X DS.W 1        ; preserve D 
  165:     000E +0002                  SETC_PR_Y DS.W 1        ; preserve D  
  166:     0010 +0002                  SETC_RA DS.W 1  ; return address
  167:                                 
  168:     2108 35                     setcode: pshy       ; {
  169:     2109 34                              pshx
  170:     210A 3B                              pshd
  171:     210B 1B 96                        leas -SETC_VARSIZE,SP   ; make room for variables
  172:     210D 180B 01 0001                 movb #TRUE, SETC_FLAG   ; byte flag = TRUE;
  173:                                                               ; byte i;
  174:                                                               ; byte input;
  175:                                                               ;int digit;
  176:     2112 1800 86 0000                 movw #0,SETC_ALARMCODE,SP   ; int alarmCode=0;
  177:     2117 1800 88 03E8                 movw #1000,SETC_MULT,SP ; int mult=1000; // multiplier
  178:     211C 6A 80                        staa SETC_IX,SP         ; save parameter value
  179:     211E                        setc_loop:                    ; do {
  180:     211E CC 251C                      ldd #GET_CODE_MSG       ;      printf(GET_CODE_MSG);
  181:     2121 15 FB CD63                   jsr [printf, PCr]
  182:     2125 69 82                        clr SETC_I,SP           ;      for(i=0 ; i< 4 ; i++)
  183:     2127                        setc_for:                     ;      {
  184:     2127 16 2382                      jsr readKey             ;         input = readKey();
  185:     212A 6B 83                        stab SETC_INPUT,SP
  186:     212C C1 64                  setc_if cmpb #'d'             ;         if(input == 'd')
  187:     212E 26 1C                        bne setc_elseif         ;         { 
  188:     2130 A6 80                  setc_if2 ldaa SETC_IX,SP      ;            if(ix == 0) 
  189:     2132 81 00                        cmpa #0
  190:     2134 26 09                        bne setc_else2
  191:     2136 CC 252A                      ldd #ERR_MST_MSG        ;               printf(ERR_MST_MSG);
  192:     2139 15 FB CD4B                   jsr [printf,PCr]
  193:     213D 20 0B                        bra setc_endif2
  194:     213F                        setc_else2                    ;            else {
  195:     213F 1800 86 FFFF                 movw #$ffff,SETC_ALARMCODE,SP ;            alarmCode = 0xffff;
  196:     2144 1808 81 00                   movb #FALSE,SETC_FLAG,SP;                  flag = FALSE;
  197:     2148 20 3E                        bra setc_endfor          ;                 break; 
  198:     214A                        setc_endif2                   ;             }
  199:     214A 20 33                        bra setc_endif          ;         }
  200:     214C                        setc_elseif:
  201:     214C A6 83                        ldaa SETC_INPUT,SP      ;         else if(isdigit(input))
  202:     214E 16 247C                      jsr isdigit
  203:     2151 97                           tsta
  204:     2152 27 22                        beq setc_else
  205:     2154 E6 83                        ldab SETC_INPUT,SP      ;         {  digit = input - ASCII_CONV_NUM;
  206:     2156 C0 30                        subb #ASCII_CONV_NUM
  207:     2158 87                           clra
  208:     2159 6C 84                        std SETC_DIGIT,SP       ;            alarmCode = alarmCode + digit * mult;
  209:     215B ED 88                        ldy SETC_MULT,SP
  210:     215D 13                           EMUL                    ; // Result digit*mult is in D
  211:     215E E3 86                        addd SETC_ALARMCODE,SP
  212:     2160 6C 86                        std SETC_ALARMCODE,SP
  213:     2162 EC 88                        ldd SETC_MULT,SP        ;            mult = mult/10;
  214:     2164 CE 000A                      ldx #10
  215:     2167 1810                         idiv
  216:     2169 6E 88                        stx SETC_MULT,SP
  217:     216B 8E 0000                      cpx #0                  ;            if(mult == 0)
  218:     216E 26 0F                        bne setc_endif          ;             
  219:     2170 1808 81 00                   movb #FALSE,SETC_FLAG,SP ;                flag = FALSE;
  220:     2174 20 09                        bra setc_endif          ;         }
  221:     2176                        setc_else:                    ;         else {
  222:     2176 CC 2510                      ldd #CERRMSG            ;                printf(CERRMSG);
  223:     2179 15 FB CD0B                   jsr [printf, PCr]
  224:     217D 20 09                        bra setc_endfor         ;                break;
  225:                                                               ;         }
  226:     217F                        setc_endif:
  227:     217F A6 82                        ldaa SETC_I,SP
  228:     2181 42                           inca
  229:     2182 6A 82                        staa SETC_I,SP
  230:     2184 81 04                        cmpa #4
  231:     2186 25 9F                        blo setc_for 
  232:     2188                        setc_endfor:                       ;   }
  233:     2188 E7 81                        tst SETC_FLAG,SP        ; } while(flag);
  234:     218A 26 92                        bne setc_loop
  235:     218C A6 80                        lda SETC_IX,SP   ; writeToEE( (int) &alarmCodes[ix], alarmCode);
  236:     218E 48                           lsla  ; double index value - 2 bytes/element
  237:     218F CE 24C2                      ldx #alarmCodes
  238:     2192 1A E4                        leax a,x
  239:     2194 EC 86                        ldd SETC_ALARMCODE,SP
  240:     2196 07 06                        bsr writeToEE
  241:     2198 1B 8A                        leas SETC_VARSIZE,SP    ; skip over variables
  242:     219A 3A                           puld                    ; restore registers
  243:     219B 30                           pulx
  244:     219C 31                           puly
  245:     219D 3D                           rts
  246:                                 ;---------------------------------
  247:                                 ; Subroutine: writeToEE()
  248:                                 ; Parameters: address - in x register
  249:                                 ;             alarmCode    - in d register
  250:                                 ; Variables: none
  251:                                 ; Description:
  252:                                 ;     Write the alarm code in EEProm. writeEEByte() is a 
  253:                                 ;     function avaible in Debug12.
  254:                                 ;------------------------------------------------------
  255:                                 ; Stack Usage
  256:                                         OFFSET 0 ; to setup offsets into stack
  257:     0000 +0002                  WREE_PR_D DS.W 1        ; preserve D - alarmCode
  258:     0002 +0002                  WREE_PR_X DS.W 1        ; preserve X - address 
  259:     0004 +0002                  WREE_RA DS.W 1  ; return address
  260:                                 
  261:     219E 34                     writeToEE:  pshx
  262:     219F 3B                                 pshd
  263:     21A0 E6 80                              ldab WREE_PR_D,SP   ;  writeEEByte(address, (byte)((alarmCode&0xff00)>>8) );
  264:     21A2 3B                                 pshd   ; save argument on stack
  265:     21A3 B7 54                              tfr x,d ; first argument passed in D
  266:     21A5 4B FB CCFD                         call [writeEEByte, PCr]
  267:     21A9 30                                 pulx  ; remove argument
  268:     21AA EE 82                              ldx WREE_PR_X,SP     ; get address
  269:     21AC E6 81                              ldab WREE_PR_D+1,SP  ; writeEEByte(address+1, (byte)(alarmCode&0xff) );
  270:     21AE 3B                                 pshd  ; save argument on stack
  271:     21AF B7 54                              tfr x,d ; first argument passed in D
  272:     21B1 C3 0001                            addd #1 ; address+1
  273:     21B4 4B FB CCEE                         call [writeEEByte, PCr]
  274:     21B8 30                                 pulx   ; remove argument
  275:     21B9 3A                                 puld   ; restore D
  276:     21BA 30                                 pulx   ; restore X
  277:     21BB 3D                                 rts
  278:                                         
  279:                                    switch globalConst
  280:     24EF 4D 61 73 74 65 72      MSTCDMSG    dc.b "Master code",NL,CR,$00
           24F5 20 63 6F 64 65 0A 
           24FB 0D 00 
  281:     24FD 61 3A 6D 73 74 72      CONFIGMSG   dc.b "a:mstr 1-4:other",NL,CR,$00
           2503 20 31 2D 34 3A 6F 
           2509 74 68 65 72 0A 0D 
           250F 00 
  282:     2510 42 61 64 20 65 6E      CERRMSG     dc.b "Bad entry",NL,CR,$00
           2516 74 72 79 0A 0D 00 
  283:     251C 43 6F 64 65 20 6F      GET_CODE_MSG dc.b "Code or 'd'",NL,CR,$00
           2522 72 20 27 64 27 0A 
           2528 0D 00 
  284:     252A 43 61 6E 6E 6F 74      ERR_MST_MSG dc.b "Cannot disable",NL,CR,$00
           2530 20 64 69 73 61 62 
           2536 6C 65 0A 0D 00 
  285:                                 
  132:                                  INCLUDE        armed.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: armed.asm
    4:                                 ; Description: The Armed Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:          =00000096              ARMDELAY  equ 150; 15000
   11:          =000001F4              BEEPDELAY equ 500
   12:                                 
   13:                                 ;-------------------------------------------
   14:                                 ; Subroutine: enableAlarm
   15:                                 ; Parameters: none
   16:                                 ; Returns: nothing
   17:                                 ; Variables
   18:                                 ;       input, codeValid, delayFlag - on stack
   19:                                 ; Description:
   20:                                 ;     Gets user to enter a valid alarm code to arm
   21:                                 ;     the alarm system.  Delays 15 seconds (to allow user
   22:                                 ;     to leave; the alarm can be disarmed during this period),
   23:                                 ;     monitors for trigger events (a, b, c, d, e).  When 'a'
   24:                                 ;     is detected, 15 seconds are allowed to enter an alarm code to
   25:                                 ;     disarm the system; otherwise the alarm is triggered. For other
   26:                                 ;     trigger events, the alarm is triggered instantly.  The alarm
   27:                                 ;     system can be turned off after being triggered with an alarm
   28:                                 ;     code.
   29:                                 ;------------------------------------------------------
   30:                                 ; Stack Usage:
   31:                                         OFFSET 0  ; to setup offset into stack
   32:     0000 +0001                  EAL_INPUT      DS.B 1  ; input
   33:     0001 +0001                  EAL_CODEVALID  DS.B 1 ; codeValid
   34:     0002 +0001                  EAL_DELAYFLAG  DS.B 1 ; delayFlag
   35:     0003                        EAL_VARSIZE:
   36:     0003 +0002                  EAL_PR_D              DS.W 1 ; preserve D
   37:     0005 +0002                  EAL_RA         DS.W 1 ; return address
   38:                                 
   39:     21BC 3B                     enableAlarm:  pshd
   40:     21BD 1B 9D                     leas  -EAL_VARSIZE,SP        ;byte input;  // input from user
   41:                                                                 ;byte codeValid;  // valid alarm code found
   42:                                                                 ;byte delayFlag;
   43:                                    ;// Get a valid alarm code to arm the system
   44:     21BF CC 253B                   ldd #CODEMSG                 ; printf(CODEMSG);
   45:     21C2 15 FB CCC2                jsr [printf, PCr]
   46:     21C6 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   47:     21CA                        eal_while1:
   48:     21CA E7 81                     tst EAL_CODEVALID,SP         ; while(!codeValid) 
   49:     21CC 26 0E                     bne eal_endwhile1            ; {
   50:     21CE 16 2382                   jsr readKey                  ;   input = readKey();
   51:     21D1 6B 80                     stab EAL_INPUT,SP
   52:     21D3 180F                      tba
   53:     21D5 16 22AF                   jsr checkCode                ;     codeValid = checkCode(input);
   54:     21D8 6A 81                     staa EAL_CODEVALID,SP
   55:     21DA 20 EE                     bra eal_while1
   56:     21DC                        eal_endwhile1                   ; }
   57:                                 
   58:     21DC CC 2542                   ldd #ARMING                   ; printf(ARMING);
   59:     21DF 15 FB CCA5                jsr [printf,PCr]
   60:                                    ; // Delay 1500 ms, i.e. 15 seconds
   61:     21E3 CC 0096                   ldd #ARMDELAY                 ; setDelay(ARMDELAY);
   62:     21E6 16 2458                   jsr setDelay
   63:     21E9 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   64:     21ED 1808 82 00                movb #FALSE,EAL_DELAYFLAG,SP ; delayFlag = FALSE;
   65:     21F1                        eal_while2:                     ; while(!delayFlag) 
   66:     21F1 E7 82                     tst EAL_DELAYFLAG,SP         ; {
   67:     21F3 26 28                     bne eal_endwhile2
   68:     21F5 16 245C                   jsr polldelay                ;   delayFlag = delay(); 
   69:     21F8 6A 82                     staa EAL_DELAYFLAG,SP
   70:     21FA 16 23AA                   jsr pollReadKey              ;   input = pollreadKey();  // check if code entered to disarm
   71:     21FD 6B 80                     stab EAL_INPUT,SP
   72:     21FF 180F                      tba
   73:     2201                        eal_if1:
   74:     2201 81 23                     cmpa #'#'                    ;   if(isdigit(input) || input == '#') 
   75:     2203 27 08                     beq eal_blk1
   76:     2205 16 247C                   jsr isdigit
   77:     2208 97                        tsta
   78:     2209 26 02                     bne eal_blk1
   79:     220B 20 0E                     bra eal_endif1   
   80:     220D                        eal_blk1:                       ;    {
   81:     220D A6 80                     ldaa EAL_INPUT,SP            
   82:     220F 16 22AF                   jsr checkCode                ;        codeValid = checkCode(input);
   83:     2212 6A 81                     staa EAL_CODEVALID,SP
   84:     2214                        eal_if2:
   85:     2214 97                        tsta                         ;        if(codeValid) 
   86:     2215 27 04                     beq eal_endif2
   87:     2217 1808 82 01                movb #TRUE,EAL_DELAYFLAG,SP  ;            delayFlag = TRUE;  // break out of loop
   88:     221B                        eal_endif2:
   89:     221B                        eal_endif1:                     ;    }
   90:     221B 20 D4                     bra eal_while2               
   91:     221D                        eal_endwhile2                   ; }
   92:                                 
   93:                                    ;// Loop to monitor trigger events and alarm code to disable
   94:                                    ;// codeValid is TRUE if valid alarm code entered during delay
   95:     221D                        eal_if3:                        ; if(!codeValid)
   96:     221D E7 81                     tst EAL_CODEVALID,SP
   97:     221F 26 07                     bne eal_endif3
   98:     2221 CC 2553                   ldd #ARMED                   ;        printf(ARMED)
   99:     2224 15 FB CC60                jsr [printf, PCr]
  100:     2228                        eal_endif3:
  101:     2228                        eal_while3                      ;  while(!codeValid)
  102:     2228 E7 81                     tst EAL_CODEVALID,SP         ; {
  103:     222A 26 7F                     bne eal_endwhile3
  104:     222C CC 2575                   ldd #TEST
  105:     222F 15 FB CC55                jsr [printf, PCr]
  106:     2233 16 23AA                   jsr pollReadKey              ;    input = pollReadKey();
  107:     2236 6B 80                     stab EAL_INPUT,SP
  108:     2238 180F                      tba
  109:     223A                        eal_elseif
  110:     223A 81 23                     cmpa #'#'                    ;    if(isdigit(input) || input == '#') 
  111:     223C 27 08                     beq eal_blk2
  112:     223E 16 247C                   jsr isdigit
  113:     2241 97                        tsta
  114:     2242 26 02                     bne eal_blk2
  115:     2244 20 08                     bra eal_elseifA  
  116:     2246                        eal_blk2:      
  117:     2246 A6 80                     ldaa EAL_INPUT,SP             ;        codeValid = checkCode(input);
  118:     2248 07 65                     bsr checkCode                
  119:     224A 6A 81                     staa EAL_CODEVALID,SP 
  120:     224C 20 59                     bra eal_endelseif    
  121:     224E                        eal_elseifA:
  122:     224E 16 24AB                   jsr getSwStatus               ;   else if(getSwStatus() & 0b00000001) // Front door opened
  123:     2251 84 01                     anda #%00000001
  124:     2253 27 3D                     beq eal_elseifB               ;   {
  125:     2255 CC 2563                   ldd #DISARMING                ;      printf(DISARMING);
  126:     2258 15 FB CC2C                jsr [printf, PCr]
  127:     225C CC 0096                   ldd #ARMDELAY                 ;      setDelay(ARMDELAY);
  128:     225F 16 2458                   jsr setDelay
  129:     2262                        eal_while4:                      ;      while(!codeValid)
  130:     2262 A6 81                     ldaa EAL_CODEVALID,SP         ;      {
  131:     2264 26 2A                     bne eal_endwhile4 
  132:     2266                        eal_if4:
  133:     2266 16 245C                   jsr pollDelay                 ;         if(pollDelay())
  134:     2269 97                        tsta  
  135:     226A 27 09                     beq eal_else4                 ;         { 
  136:     226C 16 2330                   jsr triggerAlarm              ;            triggerAlarm();
  137:     226F 1808 81 01                movb #TRUE,EAL_CODEVALID,SP   ;            codeValid = TRUE;           
  138:     2273 20 19                     bra eal_endif4                ;         }
  139:     2275                        eal_else4                        ;         else {
  140:     2275 16 23AA                   jsr pollReadKey               ;            input = pollReadKey();  // check if alarm code entered to disarm
  141:     2278 6B 80                     stab EAL_INPUT,SP
  142:     227A                        eal_if5:
  143:     227A 180F                      tba                           ;            if(isdigit(input) || input == '#')
  144:     227C 81 23                     cmpa #'#' 
  145:     227E 27 08                     beq eal_blk3
  146:     2280 16 247C                   jsr isdigit
  147:     2283 97                        tsta
  148:     2284 26 02                     bne eal_blk3
  149:     2286 20 06                     bra eal_endif5   
  150:     2288                        eal_blk3:  
  151:     2288 A6 80                     ldaa EAL_INPUT,SP
  152:     228A 07 23                     bsr checkCode                ;                 codeValid = checkCode(input);
  153:     228C 6A 81                     staa EAL_CODEVALID,SP 
  154:     228E                        eal_endif5:
  155:     228E                        eal_endif4:                     ;          }
  156:     228E 20 D2                     bra eal_while4
  157:     2290                        eal_endwhile4:                  ;        }
  158:     2290                        eal_endelseifA                  ;      }
  159:     2290 20 15                     bra eal_endelseif;      
  160:     2292                        eal_elseifB:
  161:     2292 16 24AB                   jsr getSwStatus              ;      else if(getSwStatus() & 0b11111110) // other door/window opened
  162:     2295 84 FE                     anda #%11111110           ;      
  163:     2297 27 0E                     beq eal_endelseifB           ;      {
  164:     2299 CC 2583                   ldd #FLAG
  165:     229C 15 FB CBE8                jsr [printf, PCr]
  166:     22A0 16 2330                   jsr triggerAlarm             ;          triggerAlarm();
  167:     22A3 1808 81 01                movb #TRUE,EAL_CODEVALID,SP  ;          codeValid = TRUE;
  168:     22A7                        eal_endelseifB:                 ;      }
  169:                                    ;    // ignore all other input
  170:     22A7                        eal_endelseif:
  171:     22A7 1820 FF7D                  lbra eal_while3
  172:     22AB                        eal_endwhile3                   ; }
  173:     22AB 1B 83                      leas EAL_VARSIZE,SP
  174:     22AD 3A                         puld
  175:     22AE 3D                         rts
  176:                                 
  177:                                 
  178:                                 ;------------------------------------------------------
  179:                                 ; Subroutine: checkCode
  180:                                 ; Parameters: input - accumulator A
  181:                                 ; Returns: TRUE when a valid alarm code is detected, FALSE otherwise - stored in 
  182:                                 ;          accumulator A
  183:                                 ; Local Variables: retval - on stack
  184:                                 ; Global Variables:
  185:                                 ;       mult - initilased to 1000 in inithw (Alarm System Module)
  186:                                 ;       alarmCode - initialised to 0 in inithw (Alarm System Module)
  187:                                 ; Descriptions: Creates alarm code using digits entered until
  188:                                 ;               4 digits are seen. After 4th digit, see if
  189:                                 ;               alarm code is valid using isCodeValid().
  190:                                 ;------------------------------------------------------
  191:                                 ; Stack usage
  192:                                         OFFSET 0
  193:     0000 +0001                  CKC_INPUT  DS.B 1 ; parameter input
  194:     0001 +0001                  CKC_RETVAL DS.B 1 ; variable retval
  195:     0002                        CKC_VARSIZE
  196:     0002 +0001                  CKC_PR_B          DS.B 1 ; preserve B
  197:     0003 +0002                  CKC_PR_X   DS.W 1 ; preserve X
  198:     0005 +0002                  CKC_PR_Y   DS.W 1 ; preserve Y
  199:     0007 +0002                  CKC_RA    DS.W 1 ; return address
  200:                                 
  201:     22AF 35                     checkCode: pshy
  202:     22B0 34                        pshx
  203:     22B1 37                        pshb
  204:     22B2 1B 9E                     leas -CKC_VARSIZE,SP       
  205:                                                               ; static int mult = 1000; // current multiplier of digit
  206:                                                               ; static int alarmCode = 0;   // alarm code value
  207:     22B4 1808 81 00                movb #FALSE,CKC_RETVAL,SP  ; byte retval = FALSE;
  208:     22B8 6A 80                     staa CKC_INPUT,SP          ; save paramater value
  209:                                    
  210:     22BA 16 247C                   jsr isdigit                ; if(isdigit(input))
  211:     22BD 97                        tsta
  212:     22BE 27 36                     beq ckc_else               ; {
  213:     22C0 A6 80                     ldaa CKC_INPUT,SP          ;    alarmCode = alarmCode + (input-ASCII_CONV_NUM)*mult
  214:     22C2 80 30                     suba #ASCII_CONV_NUM
  215:     22C4 180E                      tab                        
  216:     22C6 87                        clra
  217:     22C7 FD 3000                   ldy mult
  218:     22CA 13                        emul                       ; //*mult - result in D
  219:     22CB F3 3002                   addd alarmCode
  220:     22CE 7C 3002                   std alarmCode
  221:     22D1 FC 3000                   ldd mult                   ;    mult = mult/10;
  222:     22D4 CE 000A                   ldx #10
  223:     22D7 1810                      idiv
  224:     22D9 7E 3000                   stx mult
  225:     22DC FC 3000                   ldd mult                   ;    if(mult == 0) 
  226:     22DF 26 13                     bne ckc_endif1             ;    {
  227:     22E1 FC 3002                   ldd alarmcode              ;
  228:     22E4 07 24                     bsr isCodeValid            ;       retval = isCodeValid(alarmCode);
  229:     22E6 6A 81                     staa CKC_RETVAL,SP
  230:     22E8 CC 0000                   ldd #0                     ;       alarmCode = 0;
  231:     22EB 7C 3002                   std alarmCode 
  232:     22EE CC 03E8                   ldd #1000                  ;       mult = 1000;
  233:     22F1 7C 3000                   std mult     
  234:     22F4                        ckc_endif1:                   ;     }
  235:     22F4 20 0C                     bra ckc_endif              ; }
  236:     22F6                        ckc_else:                     ; else {
  237:     22F6 CC 0000                   ldd #0                     ;       alarmCode = 0;
  238:     22F9 7C 3002                   std alarmCode 
  239:     22FC CC 03E8                   ldd #1000                  ;       mult = 1000;
  240:     22FF 7C 3000                   std mult                   ; }
  241:     2302                        ckc_endif:
  242:                                    
  243:     2302 A6 81                     ldaa CKC_RETVAL,SP         ; return(retval);
  244:                                    ; Restore registers and stack
  245:     2304 1B 82                     leas CKC_VARSIZE,SP
  246:     2306 33                        pulb
  247:     2307 30                        pulx
  248:     2308 31                        puly
  249:     2309 3D                        rts      
  250:                                 
  251:                                 
  252:                                 ;------------------------------------------------------
  253:                                 ; Subroutine: isCodeValid
  254:                                 ; Parameters: alarmCode stored in register D
  255:                                 ; Local Variables
  256:                                 ;   ptr - pointer to array - in register X
  257:                                 ;   cnt, retval - on the stack.
  258:                                 ; Returns: TRUE/FALSE - Returned in accumulator A 
  259:                                 ; Description: Checks to see if alarm code is in the
  260:                                 ;              alarmCodes array.
  261:                                 ;------------------------------------------------------
  262:                                 
  263:                                 ; Stack usage
  264:                                         OFFSET 0
  265:     0000 +0002                  CDV_ALARMCODE   DS.W 1 ; alarmCode
  266:     0002 +0001                  CDV_CNT    DS.B 1 ; cnt
  267:     0003 +0001                  CDV_RETVAL DS.B 1 ; retval
  268:     0004                        CDV_VARSIZE:
  269:     0004 +0002                  CDV_PR_X   DS.W 1 ; preserve x register
  270:     0006 +0002                  CDV_RA     DS.W 1 ; return address
  271:                                 
  272:     230A 34                     isCodeValid: pshx
  273:     230B 1B 9C                     leas -CDV_VARSIZE,SP
  274:     230D 6C 80                     std CDV_ALARMCODE,SP
  275:                                    ; int *ptr;  // pointer to alarmCodes
  276:     230F 1808 82 05                movb #NUMCODES,CDV_CNT,SP ; byte cnt = 5;
  277:     2313 1808 83 00                movb #FALSE,CDV_RETVAL,SP ; byte retval = FALSE;
  278:     2317 CE 24C2                   ldx #alarmCodes           ; ptr = alarmCodes;
  279:     231A                        cdv_while                    ; do
  280:     231A EC 31                     ldd 2,X+                  ; {
  281:     231C AC 80                     cpd CDV_ALARMCODE,SP      ;    if(*ptr++ == alarmCode)
  282:     231E 26 06                     bne cdv_endif             ;    {
  283:     2320 1808 83 01                movb #TRUE,CDV_RETVAL,SP  ;      retval = TRUE;
  284:     2324 20 04                     bra cdv_endwhile          ;      break;
  285:     2326                        cdv_endif:                   ;    }
  286:     2326 63 82                     dec CDV_CNT,SP            ;   cnt--;
  287:     2328 26 F0                     bne cdv_while             ; } while(cnt != 0); 
  288:     232A                        cdv_endwhile:
  289:     232A A6 83                     ldaa CDV_RETVAL,SP         ;   return(retval);
  290:                                    ; restore registers and stack
  291:     232C 1B 84                     leas CDV_VARSIZE,SP 
  292:     232E 30                        pulx
  293:     232F 3D                        rts
  294:                                 
  295:                                 ;----------------------------
  296:                                 ; Subroutine: triggerAlarm
  297:                                 ; Parameters: none
  298:                                 ; Returns: nothing
  299:                                 ; Local Variables: retval, dobel, input - on stack
  300:                                 ; Description: Repeatedly sends a bel character to the
  301:                                 ;              terminal until a valid alarm code is entered.
  302:                                 ;----------------------------
  303:                                 ; Stack usage
  304:                                         OFFSET 0
  305:     0000 +0002                  TRA_DONE   DS.W 1 ; done
  306:     0002 +0001                  TRA_DONEINPUT  DS.B 1 ; doneInput
  307:     0003 +0001                  TRA_INPUT  DS.B 1 ; input
  308:     0004                        TRA_VARSIZE:
  309:     0004 +0002                  TRA_PR_D   DS.W 1 ; preserve D register
  310:     0006 +0002                  TRA_RA     DS.W 1 ; return address
  311:                                 
  312:     2330 3B                     triggerAlarm: pshd
  313:     2331 1B 9C                     leas -TRA_VARSIZE,SP
  314:     2333 1808 80 00                movb #FALSE,TRA_DONE,SP   ; byte done = FALSE;
  315:                                                              ; byte dobel;
  316:                                                              ; byte input;
  317:     2337                        tra_while:                   ; while(!done)
  318:     2337 E7 80                     tst TRA_DONE,SP         ; {
  319:     2339 26 38                     bne tra_endwhile
  320:     233B C6 07                     ldab #BEL                  ;    putchar(BEL);
  321:     233D 87                        clra
  322:     233E 15 FB CB44                jsr [putchar, PCr]
  323:     2342 CC 01F4                   ldd #BEEPDELAY            ;    setDelay(BEEPDELAY);   // 1 sec between beeps
  324:     2345 16 2458                   jsr setDelay
  325:     2348 1808 82 00                movb #FALSE,TRA_DONEINPUT,SP ; doneInput = FALSE;
  326:     234C                        tra_while2:                  ;    while(!doneInput) 
  327:     234C E7 82                     tst TRA_DONEINPUT,SP      ;    {
  328:     234E 26 21                     bne tra_endwhile2
  329:     2350 16 245C                   jsr polldelay             ;       doneInput = delay();
  330:     2353 6A 82                     staa TRA_DONEINPUT,SP
  331:     2355 16 23AA                   jsr pollReadKey           ;       input = pollReadKey();  // check if code entered to disarm
  332:     2358 6B 83                     stab TRA_INPUT,SP
  333:     235A 180F                      tba
  334:     235C 81 23                     cmpa #'#'                 ;       if(isdigit(input) || input == '#') 
  335:     235E 27 08                     beq tra_blk1
  336:     2360 16 247C                   jsr isdigit
  337:     2363 97                        tsta
  338:     2364 26 02                     bne tra_blk1
  339:     2366 20 07                     bra tra_endif   
  340:     2368                        tra_blk1:
  341:     2368 A6 83                     ldaa TRA_INPUT,SP
  342:     236A 16 22AF                   jsr checkCode             ;                done = checkCode(input);
  343:     236D 6A 80                     staa TRA_DONE,SP 
  344:     236F                        tra_endif: 
  345:     236F 20 DB                     bra tra_while2
  346:     2371                        tra_endwhile2                ;    }
  347:     2371 20 C4                     bra tra_while
  348:     2373                        tra_endwhile                 ; }
  349:     2373 1B 84                     leas TRA_VARSIZE,SP
  350:     2375 3A                        puld
  351:     2376 3D                        rts
  352:                                 
  353:                                 ;-------------------------------------------------------------------------
  354:                                 ; Data Structures
  355:                                 ;-------------------------------------------------------------------------
  356:                                         SWITCH globalConst
  357:                                 ; Message strings
  358:     253B 43 6F 64 65 0A 0D      CODEMSG dc.b  "Code",NL,CR,$00
           2541 00 
  359:     2542 2A 2A 2A 20 41 72      ARMING  dc.b  "*** Arming ***",NL,CR,$00
           2548 6D 69 6E 67 20 2A 
           254E 2A 2A 0A 0D 00 
  360:     2553 2A 2A 2A 20 41 72      ARMED   dc.b  "*** Armed ***",NL,CR,$00
           2559 6D 65 64 20 2A 2A 
           255F 2A 0A 0D 00 
  361:     2563 2D 2D 20 44 69 73      DISARMING dc.b  "-- Disarming --",NL,CR,$00
           2569 61 72 6D 69 6E 67 
           256F 20 2D 2D 0A 0D 00 
  362:     2575 2D 2D 20 54 45 53      TEST dc.b  "-- TEST! --",NL,CR,$00
           257B 54 21 20 2D 2D 0A 
           2581 0D 00 
  363:     2583 2D 2D 20 46 4C 41      FLAG dc.b  "-- FLAG --",NL,CR,$00
           2589 47 20 2D 2D 0A 0D 
           258F 00 
  364:                                 
  365:                                    switch globalVar
  366:     3000 03E8                   mult dc.w 1000
  367:     3002 0000                   alarmCode dc.w 0
  133:                                  INCLUDE keyPad.asm
    1:                                 ;----------------------------------------------------------------------
    2:                                 ; File: Keypad.asm
    3:                                 ; Author:
    4:                                 
    5:                                 ; Description:
    6:                                 ;  This contains the code for reading the
    7:                                 ;  16-key keypad attached to Port A
    8:                                 ;  See the schematic of the connection in the
    9:                                 ;  design document.
   10:                                 ;
   11:                                 ;  The following subroutines are provided by the module
   12:                                 ;
   13:                                 ; char pollReadKey(): to poll keypad for a keypress
   14:                                 ;                 Checks keypad for 2 ms for a keypress, and
   15:                                 ;                 returns NOKEY if no keypress is found, otherwise
   16:                                 ;                 the value returned will correspond to the
   17:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   18:                                 ; void initkey(): Initialises Port A for the keypad
   19:                                 ;
   20:                                 ; char readKey(): to read the key on the keypad
   21:                                 ;                 The value returned will correspond to the
   22:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   23:                                 ;---------------------------------------------------------------------
   24:                                 
   25:                                 ; Include header files
   26:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
   27:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   28:                                 
   29:                                 **************EQUATES**********
   30:                                 
   31:                                 ;-----Conversion table
   32:          =00000010              NUMKEYS         EQU     16              ; Number of keys on the keypad
   33:          =000000FF              BADCODE         EQU     $FF     ; returned of translation is unsuccessful
   34:          =00000000              NOKEY                   EQU $00   ; No key pressed during poll period
   35:          =00000001              POLLCOUNT       EQU     1     ; Number of loops to create 1 ms poll time
   36:     3004 +0001                  PDELAY          RMB 1                   ; Variable to achieve propagation delay
   37:                                 
   38:                                  SWITCH globalConst  ; Constant data
   39:                                 
   40:                                  SWITCH code_section  ; place in code section
   41:                                 ;-----------------------------------------------------------    
   42:                                 ; Subroutine: initKeyPad
   43:                                 ;
   44:                                 ; Description: 
   45:                                 ;       Initiliases PORT A by setting input and output pins 
   46:                                 ;       and enabling pull resistors
   47:                                 ;-----------------------------------------------------------    
   48:     2377 36                     initKeyPad: psha
   49:                                 
   50:     2378 86 F0                          ldaa #$F0   ; Set to PA4-7 as output and PA0-3 as input
   51:     237A 5A 02                    staa DDRA
   52:                                 
   53:     237C 86 01                          ldaa #$01               ; Enable pull-up resistors for Port A (bit 0 PUPAE)
   54:     237E 5A 0C                          staa PUCR 
   55:                                 
   56:     2380 32                             pula
   57:     2381 3D                             rts
   58:                                 
   59:                                 ;-----------------------------------------------------------    
   60:                                 ; Subroutine: ch <- pollReadKey
   61:                                 ; Parameters: none
   62:                                 ; Local variable:
   63:                                 ; Returns:
   64:                                 ;       ch: NOKEY when no key pressed,
   65:                                 ;       otherwise, ASCII Code in accumulator B
   66:                                 
   67:                                 ; Description:
   68:                                 ;  Loops for a period of 2ms, checking to see if
   69:                                 ;  key is pressed. Calls readKey to read key if keypress 
   70:                                 ;  detected (and debounced) on Port A and get ASCII code for
   71:                                 ;  key pressed.
   72:                                 ;-----------------------------------------------------------
   73:                                 ; Stack Usage
   74:                                         OFFSET 0  ; to setup offset into stack
   75:                                 
   76:     2382 36                     readKey: psha
   77:                                 
   78:     2383                        prk_initial_loop:
   79:     2383 86 00                                  ldaa #$00                                                       ; do {
   80:     2385 5A 00                                  staa PORTA                                              ;       PORTA = 0b00000000 // Set all the output pins to LOW to detect key press
   81:     2387 96 00                                  ldaa PORTA                                              
   82:     2389 84 0F                                  anda #%00001111                         
   83:     238B 81 0F                                  cmpa #%00001111                         
   84:     238D 27 F4                                  beq prk_initial_loop    ; } while (PORTA & 0x0F == 0x0F);
   85:                                 
   86:     238F D6 00                                  ldab PORTA                      ; prev_PORTA = PORTA // Store in accumulator B
   87:                                 
   88:     2391 3B                                     pshd
   89:     2392 CC 0014                                ldd #20                                                         ; delayms(2);
   90:     2395 16 244F                                jsr delayms
   91:     2398 3A                                     puld
   92:                                 
   93:     2399 96 00                                  ldaa PORTA                                              ; if (PORTA != prev_PORTA)
   94:     239B 1817                                   cba     
   95:     239D 26 07                                  bne prk_nokey                                   ;       return NOKEY;
   96:                                 
   97:     239F 16 23AA                                jsr pollReadKey                                         ; code = readKey();
   98:     23A2 C1 FF                                  cmpb #BADCODE                                   ; if (code != BADCODE)
   99:     23A4 26 02                                  bne prk_end                                             ;       return code;
  100:                                                                                                                                         ; else 
  101:     23A6                        prk_nokey:
  102:     23A6 C6 00                                  ldab #NOKEY                                             ;       return NOKEY;
  103:                                 
  104:     23A8                        prk_end:
  105:     23A8 32                                     pula
  106:     23A9 3D                             rts
  107:                                 
  108:                                 ;-----------------------------------------------------------    
  109:                                 ; Subroutine: ch <- readKey
  110:                                 ; Arguments: none
  111:                                 ; Local variable: 
  112:                                 ;       ch - ASCII Code in accumulator B
  113:                                 
  114:                                 ; Description:
  115:                                 ;  Main subroutine that reads a code from the
  116:                                 ;  keyboard using the subroutine readKeybrd.  The
  117:                                 ;  code is then translated with the subroutine
  118:                                 ;  translate to get the corresponding ASCII code.
  119:                                 ;-----------------------------------------------------------    
  120:                                 ; Stack Usage
  121:                                         OFFSET 0  ; to setup offset into stack
  122:                                 
  123:     23AA 36                     pollReadKey:psha
  124:                                 
  125:     23AB 86 E0                                  ldaa #%11100000
  126:     23AD 5A 00                                  staa PORTA                                              ; PORTA = 11100000                      // Set row 0
  127:     23AF 16 2403                                jsr propagation_delay           ; propagation_delay();  // delay for stability
  128:     23B2 D6 00                                  ldab PORTA                                                      ; code = translate(PORTA);
  129:     23B4 16 242E                                jsr translate
  130:     23B7 C1 FF                                  cmpb #BADCODE                                           ; if (code == BADCODE)
  131:     23B9 26 2C                                  bne rk_debounce                                 ;       rk_debounce();
  132:                                 
  133:     23BB 86 D0                                  ldaa #%11010000
  134:     23BD 5A 00                                  staa PORTA                                                      ; PORTA = 11010000                      // Set row 1
  135:     23BF 16 2403                                jsr propagation_delay           ; propagation_delay();  // delay for stability
  136:     23C2 D6 00                                  ldab PORTA                                                      ; code = translate(PORTA);
  137:     23C4 16 242E                                jsr translate
  138:     23C7 C1 FF                                  cmpb #BADCODE                                           ; if (code == BADCODE)
  139:     23C9 26 1C                                  bne rk_debounce                                 ;       rk_debounce();
  140:                                 
  141:     23CB 86 B0                                  ldaa #%10110000
  142:     23CD 5A 00                                  staa PORTA                                                      ; PORTA = 10110000                      // Set row 2
  143:     23CF 16 2403                                jsr propagation_delay           ; propagation_delay();  // delay for stability
  144:     23D2 D6 00                                  ldab PORTA                                                      ; code = translate(PORTA);
  145:     23D4 16 242E                                jsr translate
  146:     23D7 C1 FF                                  cmpb #BADCODE                                           ; if (code == BADCODE)
  147:     23D9 26 0C                                  bne rk_debounce                                 ;       rk_debounce();
  148:                                 
  149:     23DB 86 70                                  ldaa #%01110000
  150:     23DD 5A 00                                  staa PORTA                                                      ; PORTA = 01110000                      // Set row 3
  151:     23DF 16 2403                                jsr propagation_delay           ; propagation_delay();  // delay for stability
  152:     23E2 D6 00                                  ldab PORTA                                                      ; code = translate(PORTA);
  153:     23E4 16 242E                                jsr translate
  154:                                                 
  155:     23E7                        rk_debounce:
  156:     23E7 96 00                                  ldaa PORTA                                                      ; while (PORTA & 0x0F < 0x0F);
  157:     23E9 84 0F                                  anda #$0F                                                
  158:     23EB 81 0F                                  cmpa #$0F
  159:     23ED 2D F8                                  blt rk_debounce
  160:                                 
  161:     23EF 37                                     pshb
  162:     23F0 CC 000F                                ldd #15                                                                 ; delayms(10);
  163:     23F3 16 244F                                jsr delayms
  164:     23F6 33                                     pulb
  165:                                 
  166:     23F7 96 00                                  ldaa PORTA                                                      ; if (PORTA & 0x0F == 0x0F) 
  167:     23F9 84 0F                                  anda #$0F                                                               ;       // Confirm that all buttons are released (inputs all 1s)
  168:     23FB 81 0F                                  cmpa #$0F
  169:     23FD 27 02                                  beq rk_end
  170:                                 
  171:     23FF                        rk_return_bad:
  172:     23FF C6 FF                                  ldab #BADCODE                                           ;       return(BADCODE);
  173:                                 
  174:     2401                        rk_end
  175:     2401 32                                     pula
  176:     2402 3D                                     rts                                                                                     ; return(ch);
  177:                                 
  178:                                 ;-----------------------------------------------------------    
  179:                                 ; Subroutine:  propagation_delay
  180:                                 ; Arguments: none
  181:                                 ; Returns: none
  182:                                 ; Local Variables
  183:                                 ;       PDELAY - in Reserve Memory Bytes (RMB) - number of delay cycles
  184:                                 ; Description:
  185:                                 ;   Creates a short delay used in between setting outputs of 
  186:                                 ;       PORTA and reading inputs of PORTA to ensure stability
  187:                                 ;-----------------------------------------------------------    
  188:                                 ; Stack Usage:
  189:                                    OFFSET 0
  190:     2403 180B 08 3004           propagation_delay: movb  #$08, PDELAY 
  191:     2408                        pdelay_loop:                            
  192:     2408 73 3004                                dec   PDELAY
  193:     240B 26 FB                                  bne   pdelay_loop
  194:     240D 3D                                     rts
  195:                                 
  196:                                 ; defnitions for structure cnvTbl_struct
  197:                                  OFFSET 0
  198:     0000 +0001                  cnvTbl_code ds.b 1
  199:     0001 +0001                  cnvTbl_ascii  ds.b 1
  200:          =00000002              cnvTbl_struct_len EQU *
  201:                                 
  202:                                 ; Conversion Table
  203:     240E EE 31                  cnvTbl  dc.b %11101110,'1'
  204:     2410 ED 32                          dc.b %11101101,'2'
  205:     2412 EB 33                          dc.b %11101011,'3'
  206:     2414 E7 61                          dc.b %11100111,'a'
  207:     2416 DE 34                          dc.b %11011110,'4'
  208:     2418 DD 35                          dc.b %11011101,'5'
  209:     241A DB 36                          dc.b %11011011,'6'
  210:     241C D7 62                          dc.b %11010111,'b'
  211:     241E BE 37                          dc.b %10111110,'7'
  212:     2420 BD 38                          dc.b %10111101,'8'
  213:     2422 BB 39                          dc.b %10111011,'9'
  214:     2424 B7 63                          dc.b %10110111,'c'
  215:     2426 7E 2A                          dc.b %01111110,'*'
  216:     2428 7D 30                          dc.b %01111101,'0'
  217:     242A 7B 23                          dc.b %01111011,'#'
  218:     242C 77 64                          dc.b %01110111,'d'
  219:                                 
  220:                                 ;-----------------------------------------------------------    
  221:                                 ; Subroutine:  ch <- translate(code)
  222:                                 ; Arguments
  223:                                 ;       code - in Acc B - code read from keypad port
  224:                                 ; Returns
  225:                                 ;       ch - saved on stack but returned in Acc B - ASCII code
  226:                                 ; Local Variables
  227:                                 ;       ptr - in register X - pointer to the table
  228:                                 ;       count - counter for loop in accumulator A
  229:                                 ; Description:
  230:                                 ;   Translates the code by using the conversion table
  231:                                 ;   searching for the code.  If not found, then BADCODE
  232:                                 ;   is returned.
  233:                                 ;-----------------------------------------------------------    
  234:                                 ; Stack Usage:
  235:                                    OFFSET 0
  236:     0000 +0001                  TR_CH DS.B 1  ; for ch 
  237:     0001 +0001                  TR_PR_A DS.B 1 ; preserved regiters A
  238:     0002 +0001                  TR_PR_X DS.B 1 ; preserved regiters X
  239:     0003 +0002                  TR_RA DS.W 1 ; return address
  240:                                 
  241:     242E 36                     translate: psha
  242:     242F 34                             pshx                                                                                                    ; preserve registers
  243:     2430 1B 9F                          leas -1,SP                                                              ; byte chascii;
  244:     2432 CE 240E                        ldx #cnvTbl                                                             ; ptr = cnvTbl;
  245:     2435 87                             clra                                                                                    ; ix = 0;
  246:     2436 1808 80 FF                     movb #BADCODE,TR_CH,SP                          ; ch = BADCODE;
  247:                                 
  248:     243A                        TR_loop                                                                                 ; do {
  249:     243A E1 00                          cmpb cnvTbl_code,X                      ;     if(code == ptr->code)
  250:     243C 26 06                          bne TR_endif
  251:                                                                                                                                                 ;     {
  252:     243E 180A 01 80                     movb cnvTbl_ascii,X,TR_CH,SP    ;        ch <- [ptr+1]
  253:     2442 20 07                          bra TR_endwh                                            ;        break;
  254:                                 
  255:     2444                        TR_endif                                                                        ;     } else {  
  256:     2444 1A 02                          leax cnvTbl_struct_len,X        ;           ptr++;
  257:     2446 42                             inca    ; increment count       ;           ix++;
  258:                                                                 ;     } 
  259:     2447 81 10                          cmpa #NUMKEYS                   ;} WHILE (count < NUMKEYS)
  260:     2449 25 EF                          blo TR_LOOP     
  261:     244B                        tr_endwh ; ENDWHILE
  262:                                 
  263:     244B 33                             pulb ; move ch to Acc B
  264:                                         ; restore registres
  265:     244C 30                             pulx
  266:     244D 32                             pula
  267:     244E 3D                             rts
  134:                                  INCLUDE        delay.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: delay.asm
    4:                                 ; Description: The Delay Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
    9:                                  include "alarm.inc"
    1:                                 ;---------------------------------
    2:                                 ; File: alarmSimul.inc
    3:                                 ; Description: Include file for Alarm System Simulation
    4:                                 ;              project
    5:                                 ;----------------------------------------------
    6:                                         IFNDEF ALARM_SIMUL_HDR  ; Start of conditional assembly
   21:                                          ENDIF  ; End of conditional assembly
   10:                                 
   11:                                 ; Some definitions
   12:          =00000BB8              MSCOUNT equ 3000
   13:                                 
   14:                                         SWITCH code_section
   15:                                 
   16:                                 ;-------------------------------
   17:                                 ; Subroutine delayms
   18:                                 ; Parameters: num - number of milliseconds to delay - in D
   19:                                 ; Returns: nothing
   20:                                 ; Description: Delays for num ms. 
   21:                                 ;--------------------------------
   22:     244F 3B                     delayms: pshd  
   23:     2450                        dlms_while:           ; do
   24:     2450 16 246F                   jsr delay1ms       ; delay1ms()
   25:     2453 04 34 FA                  dbne d,dlms_while  ; num--; while(num !=0)
   26:     2456                        dlms_endwhile:
   27:     2456 3A                        puld            ; restores register
   28:     2457 3D                        rts
   29:                                 
   30:                                 ;------------------------------------------------------
   31:                                 ; Subroutine setDelay
   32:                                 ; Parameters: cnt - accumulator D
   33:                                 ; Returns: nothing
   34:                                 ; Global Variables: delayCount
   35:                                 ; Description: Intialises the delayCount 
   36:                                 ;              variable.
   37:                                 ;------------------------------------------------------
   38:     2458 7C 3005                setDelay: std delayCount     ; delayCount = cnt;
   39:     245B 3D                        rts
   40:                                 
   41:                                 
   42:                                 ;------------------------------------------------------
   43:                                 ; Subroutine: polldelay
   44:                                 ; Parameters:  none
   45:                                 ; Returns: TRUE when delay counter reaches 0 - in accumulator A
   46:                                 ; Local Variables
   47:                                 ;   retval - acc A cntr - X register
   48:                                 ; Global Variables:
   49:                                 ;      delayCount
   50:                                 ; Description: The subroutine delays for 1 ms, decrements delayCount.
   51:                                 ;              If delayCount is zero, return TRUE; FALSE otherwise.
   52:                                 ;------------------------------------------------------
   53:                                 ; Stack Usage:
   54:                                         OFFSET 0  ; to setup offset into stack
   55:     0000                        PDLY_VARSIZE:
   56:     0000 +0002                  PDLY_PR_X   DS.W 1 ; preserve X
   57:     0002 +0002                  PDLY_RA     DS.W 1 ; return address
   58:                                 
   59:     245C 34                     polldelay:  pshx
   60:     245D 86 00                     ldaa #FALSE     ; byte retval=FALSE; // return value
   61:     245F 16 246F                   jsr delay1ms    ; delay1ms();
   62:     2462 FE 3005                   ldx delayCount    ; delayCount--;
   63:     2465 09                        dex
   64:     2466 7E 3005                   stx delayCount
   65:     2469                        pld_if:
   66:     2469 26 02                     bne pld_endif    ; if(delayCount==0) 
   67:     246B 86 01                     ldaa #TRUE        ; retval=TRUE;
   68:     246D                        pld_endif:
   69:                                    ; restore registers and stack
   70:     246D 30                        pulx
   71:     246E 3D                        rts
   72:                                 
   73:                                 ;------------------------
   74:                                 ; Subroutine: delay1ms
   75:                                 ; Parameters:  none
   76:                                 ; Returns: nothing
   77:                                 ; Description: The subroutine delays for 1 ms and returns.      
   78:                                 ;   Core Clock is set to 24 MHz, so 1 cycle is 41 2/3 ns
   79:                                 ;   NOP takes up 1 cycle, thus 41 2/3 ns
   80:                                 ;   Need 24 cyles to create 1 microsecond delay
   81:                                 ;   8 cycles creates a 333 1/3 nano delay
   82:                                 ;       DEX - 1 cycle
   83:                                 ;       BNE - 3 cyles - when branch is taken
   84:                                 ;       Need 4 NOP
   85:                                 ;   Run Loop 3000 times to create a 1 ms delay   
   86:                                 ;---------------------------
   87:                                 ; Stack Usage:
   88:                                         OFFSET 0  ; to setup offset into stack
   89:     0000                        DLY1_VARSIZE:
   90:     0000 +0002                  DLY1_PR_X   DS.W 1 ; preserve X
   91:     0002 +0002                  DLY1_RA     DS.W 1 ; return address
   92:                                 
   93:     246F 34                     delay1ms: pshx
   94:     2470 CE 0BB8                   ldx #MSCOUNT    ; byte cntr = MSCOUNT;
   95:     2473                        dly1_while:
   96:     2473 27 05                     beq dly1_endwhile ; while(cntr != 0)
   97:                                                      ; {
   98:     2475 A7                        nop               ;   asm { nop; nop; nop; nop; }
   99:                                    ;nop
  100:                                    ;nop
  101:     2476 A7                        nop
  102:     2477 09                        dex               ;   cntr--;
  103:     2478 20 F9                     bra dly1_while    ; }
  104:     247A                        dly1_endwhile:
  105:     247A 30                        pulx
  106:     247B 3D                        rts
  107:                                 
  108:                                 ;------------------------------------------------------
  109:                                 ; Global variables
  110:                                 ;------------------------------------------------------
  111:                                    switch globalVar
  112:     3005 +0002                  delayCount ds.w 1   ; 2 byte delay counter
  135:                                  INCLUDE        utilities.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: utilities.asm
    4:                                 ; Description: The Utilities Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:                                 
   11:                                 ;------------------------------------------------------
   12:                                 ; Subroutine isdigit
   13:                                 ; Parameters: chr - received in accumulator A/moved to B 
   14:                                 ; Returns: TRUE - chr is a digit, FALSE otherwise
   15:                                 ; Variables: retval in accumulator A
   16:                                 ; Description: Returns TRUE if chr is a digit character
   17:                                 ;              and FALSE otherwise.
   18:                                 ;------------------------------------------------------
   19:     247C 37                     isdigit: pshb   ; save B on stack
   20:     247D 180E                      tab          ; save Parameter in B
   21:     247F 86 00                     ldaa #FALSE  ;   byte retval = FALSE;
   22:     2481 C1 30                     cmpb #'0'    ;   if(chr >= '0' && chr <= '9') retval = TRUE;
   23:     2483 25 06                     blo ISD_endif
   24:     2485 C1 39                     cmpb #'9'
   25:     2487 22 02                     bhi ISD_endif
   26:     2489 86 01                     ldaa #TRUE
   27:     248B                        ISD_endif:
   28:     248B 33                        pulb         ; restore B
   29:     248C 3D                        rts          ; return(retval); // in A
   30:                                 
   31:                                 
   32:                                 
   33:                                 ;------------------------------------------------------
   34:                                 ; Subroutine: pollgetchar
   35:                                 ; Parameters:  none
   36:                                 ; Returns: char read from SC0 or NOCHAR if none available
   37:                                 ;          Returned in Acc A
   38:                                 ; Variables:
   39:                                 ;      ptr in X register
   40:                                 ;      sum in Accumulator B       
   41:                                 ; Description: Checks the RDRF bit to see if a character
   42:                                 ;              is available before reading a character using getchar.
   43:                                 ;------------------------------------------------------
   44:                                 
   45:     248D 36                     polgetchar: psha     ; gechar destroys contents of acc A
   46:     248E C6 FF                    ldab #NOCHAR        ;  char chr = NOCHAR;
   47:                                   
   48:     2490 4F CC 20 04              brclr sc0sr1,%00100000,PGC_endif ; if(SCI0SR1_RDRF==1) 
   49:     2494 15 FB C9EC               jsr [getchar, PCr]  ;                    chr = getchar();
   50:     2498                        PGC_endif
   51:     2498 32                        pula            ; restore registers
   52:     2499 3D                        rts             ; return(chr);  in ACC B
  136:                                  INCLUDE switches.asm
    1:                                 ;-------------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File:  switches.asm
    4:                                 ; Description: This file contains the Switches module for the
    5:                                 ;              Alarm System project.
    6:                                 ;-----------------------------------------------------------------*/
    7:                                 ; Include header files
    8:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
    9:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   10:                                 
   11:                                  SWITCH code_section  ; place in code section
   12:                                 ;----------------------------------------
   13:                                 ; Subroutine: initSwitches
   14:                                 ; Parameters: none
   15:                                 ; Returns: nothing
   16:                                 ; Description: Initialises the port for monitoring the switches
   17:                                 ;              and controlling LEDs.
   18:                                 ;----------------------------------------
   19:     249A 79 0262                initSwitches: clr  DDRH         ; DDRH = 0; // set to input (switches)
   20:     249D 180B FF 0264              movb #$ff,PERH     ; PERH = 0xff; // Enable pull-up/pull-down 
   21:     24A2 79 0265                   clr  PPSH     ; PPSH = 0x00; // pull-up device connected to H
   22:     24A5 180B FF 0265              movb #$ff,PPSH     ; PPSH = 0xff; // Enable pull-up/pull-down 
   23:                                                      ;             // switches ground the pins when closed.
   24:     24AA 3D                        rts
   25:                                 
   26:                                 ;------------------------
   27:                                 ; Subrooutine: getSwStatus
   28:                                 ; Parameters:  none
   29:                                 ; Returns: Acc A - An 8 bit code that indicates which
   30:                                 ;          switches are opened (bit set to 1).
   31:                                 ; Description: Checks status of switches and 
   32:                                 ;              returns bytes that shows their
   33:                                 ;              status.      
   34:                                 ;---------------------------
   35:     24AB 37                     getSwStatus: pshb
   36:     24AC F6 0260                        ldab PTH
   37:                                 
   38:     24AF 3B                             pshd
   39:     24B0 CC 0002                        ldd #2
   40:     24B3 16 244F                        jsr delayms
   41:     24B6 3A                             puld
   42:                                 
   43:     24B7 B6 0260                        ldaa PTH
   44:     24BA 1817                           cba
   45:     24BC 27 02                          beq swReturn
   46:                                 
   47:     24BE                        swReturnNone:
   48:     24BE 86 00                          ldaa #$00
   49:                                 
   50:     24C0                        swReturn:
   51:     24C0 33                             pulb    
   52:     24C1 3D                             rts
   53:                                 
  137:                                 
  138:                                    switch code_section
  139:     24C2                        ENDCODE ;  used to define where the dataEEPROM section starts
  140:                                         end                ; end of program

Symbols:
alarmcode                       *00003002
alarmcodes                      *000024c2
armdelay                        *00000096
armed                           *00002553
arming                          *00002542
ascii_conv_num                  *00000030
badcode                         *000000ff
beepdelay                       *000001f4
bel                             *00000007
cdv_alarmcode                   *00000000
cdv_cnt                         *00000002
cdv_endif                       *00002326
cdv_endwhile                    *0000232a
cdv_retval                      *00000003
cdv_varsize                     *00000004
cdv_while                       *0000231a
cerrmsg                         *00002510
cfg_else2                       *00002096
cfg_elseif2                     *00002088
cfg_endif1                      *000020a5
cfg_endif2                      *000020a1
cfg_flag                        *00000002
cfg_input                       *00000001
cfg_loop                        *0000206b
cfg_varsize                     *00000003
checkcode                       *000022af
ckc_else                        *000022f6
ckc_endif                       *00002302
ckc_endif1                      *000022f4
ckc_input                       *00000000
ckc_retval                      *00000001
ckc_varsize                     *00000002
clksel                          *00000039
cnvtbl                          *0000240e
cnvtbl_ascii                    *00000001
cnvtbl_code                     *00000000
cnvtbl_struct_len               *00000002
codemsg                         *0000253b
configcodes                     *00002062
configmsg                       *000024fd
cr                              *0000000d
crgflg                          *00000037
ddra                            *00000002
ddrh                            *00000262
delay1ms                        *0000246f
delaycount                      *00003005
delayms                         *0000244f
disarming                       *00002563
dlms_while                      *00002450
dly1_endwhile                   *0000247a
dly1_while                      *00002473
eal_blk1                        *0000220d
eal_blk2                        *00002246
eal_blk3                        *00002288
eal_codevalid                   *00000001
eal_delayflag                   *00000002
eal_else4                       *00002275
eal_elseifa                     *0000224e
eal_elseifb                     *00002292
eal_endelseif                   *000022a7
eal_endelseifb                  *000022a7
eal_endif1                      *0000221b
eal_endif2                      *0000221b
eal_endif3                      *00002228
eal_endif4                      *0000228e
eal_endif5                      *0000228e
eal_endwhile1                   *000021dc
eal_endwhile2                   *0000221d
eal_endwhile3                   *000022ab
eal_endwhile4                   *00002290
eal_input                       *00000000
eal_varsize                     *00000003
eal_while1                      *000021ca
eal_while2                      *000021f1
eal_while3                      *00002228
eal_while4                      *00002262
emc_alarmcode                   *00000003
emc_endfor                      *00002100
emc_endif2                      *000020f7
emc_endif3                      *000020f7
emc_for                         *000020c5
emc_i                           *00000001
emc_input                       *00000002
emc_mult                        *00000005
emc_retval                      *00000000
emc_varsize                     *00000007
enablealarm                     *000021bc
endcode                         *000024c2
entermstcode                    *000020a9
err_mst_msg                     *0000252a
false                           *00000000
flag                            *00002583
get_code_msg                    *0000251c
getchar                         *0000ee84
getswstatus                     *000024ab
inithw                          *0000202c
initkeypad                      *00002377
initswitches                    *0000249a
iscodevalid                     *0000230a
isd_endif                       *0000248b
isdigit                         *0000247c
mainloop                        *0000200b
menu                            *000024cc
mnelse                          *00002029
mnelseif                        *00002020
mnendif                         *00002029
mscount                         *00000bb8
mstcdmsg                        *000024ef
mult                            *00003000
nl                              *0000000a
nochar                          *000000ff
nokey                           *00000000
numcodes                        *00000005
numkeys                         *00000010
pdelay                          *00003004
pdelay_loop                     *00002408
perh                            *00000264
pgc_endif                       *00002498
pld_endif                       *0000246d
pllctl                          *0000003a
polldelay                       *0000245c
pollreadkey                     *000023aa
porta                           *00000000
ppsh                            *00000265
printf                          *0000ee88
prk_end                         *000023a8
prk_initial_loop                *00002383
prk_nokey                       *000023a6
program                         *00002000
propagation_delay               *00002403
pth                             *00000260
pucr                            *0000000c
putchar                         *0000ee86
readkey                         *00002382
refdv                           *00000035
regblk                          *00000000
rk_debounce                     *000023e7
rk_end                          *00002401
sc0bdh                          *000000c8
sc0cr2                          *000000cb
sc0sr1                          *000000cc
setc_alarmcode                  *00000006
setc_digit                      *00000004
setc_else                       *00002176
setc_else2                      *0000213f
setc_elseif                     *0000214c
setc_endfor                     *00002188
setc_endif                      *0000217f
setc_endif2                     *0000214a
setc_flag                       *00000001
setc_for                        *00002127
setc_i                          *00000002
setc_input                      *00000003
setc_ix                         *00000000
setc_loop                       *0000211e
setc_mult                       *00000008
setc_varsize                    *0000000a
setcode                         *00002108
setdelay                        *00002458
stack                           *00002000
swreturn                        *000024c0
synr                            *00000034
test                            *00002575
tr_ch                           *00000000
tr_endif                        *00002444
tr_endwh                        *0000244b
tr_loop                         *0000243a
tra_blk1                        *00002368
tra_done                        *00000000
tra_doneinput                   *00000002
tra_endif                       *0000236f
tra_endwhile                    *00002373
tra_endwhile2                   *00002371
tra_input                       *00000003
tra_varsize                     *00000004
tra_while                       *00002337
tra_while2                      *0000234c
translate                       *0000242e
triggeralarm                    *00002330
true                            *00000001
variables                       *00003000
wait_b3                         *00002043
wree_pr_d                       *00000000
wree_pr_x                       *00000002
writeeebyte                     *0000eea6
writetoee                       *0000219e

